<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Link Yan</title>
  <updated>2013-05-13T13:02:51+08:00</updated>
  <id>/</id>
  <author>
    <name>Link Yan</name>
    <email>wsyanligang@gmail.com</email>
  </author>

  
  <entry>
    <title>正太到不行~</title>
    <link href="///2013/05/13/yino.html"/>
    <updated>2013-05-13T00:00:00+08:00</updated>
    <id>///2013/05/13/yino</id>
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/wsyanligang_v/CRbeVLHq/3JJtY.png&quot; alt=&quot;Car&quot; title=&quot;小正太&quot;&gt;&lt;/p&gt;

&lt;p&gt;如需合作，请联系 &lt;a href=&quot;http://www.weibo.com/u/1825090347&quot;&gt;@颜乐环&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>45个习惯</title>
    <link href="///2013/05/12/sss.html"/>
    <updated>2013-05-12T00:00:00+08:00</updated>
    <id>///2013/05/12/sss</id>
    <content type="html">&lt;h2&gt;态度决定一切&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;做事&lt;/li&gt;
&lt;li&gt;欲速则不达&lt;/li&gt;
&lt;li&gt;对事不对人&lt;/li&gt;
&lt;li&gt;排除万难，奋勇前进&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/wsyanligang_v/CQJf7rqQ/NkrqN.png&quot; alt=&quot;Car&quot; title=&quot;car&quot;&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>创建属于你自己的3D ListView (译)</title>
    <link href="///2013/05/11/custom-adapterview.html"/>
    <updated>2013-05-11T00:00:00+08:00</updated>
    <id>///2013/05/11/custom-adapterview</id>
    <content type="html">&lt;p&gt;本文是教你如何在安卓应用中做出很酷效果的ListView的教材第一章，我叫Anders Ericson，主要从事UI工作，在Timescape应用中有个就是我做的，你可以在Xperia X10 mini 和 Xperia X10 mini pro中找到.当用户尝试使用一个App时，UI是他们第一个关注的东西,所以我决定做一个教材，使得其他任何安卓开发者可以创建属于他们自己的ListView,类似与在Timescape中的3D感觉和物理特性(dynamics).&lt;/p&gt;

&lt;p&gt;在教材的第一章，我们将创建一个很基础的list，然后在接下去的两章中，越来越多的功能和特性将添加进来。我同时也会教你如何使用list的基本构造，然后改变它使得无论如何工作的都使你的应用做到最好。下面那个链接是第一章的源码，已经为你准备好构建在如Eclipse这样的IDE中。同时不要忘了下载Sony Ericsson Tutorials 应用从Android Market中，你可以尝试使用同样的应用在教材的每一步。我很期待看到你的评论和问题。&lt;/p&gt;

&lt;p&gt;Android中标准的ListView已经支持了很多东西，并且包括了绝大多数的你可以想到的用户事件。但是listview看起来太平淡了，当你想继承它并且做很多事情时，都发现做不到，然后无疾而终。标准ListView的另一个缺点是缺乏好的物理特性（和改变它的能力）。因此，如果你要你的UI看起来不那么普通的话，你要做的仅仅是实现你自己的View.&lt;/p&gt;

&lt;p&gt;因为在一篇文章中写完会有太多的代码，所以我准备分为3部分。第一部分（就是这章）先创建一个基本的List，有太多的东西要去包括，但我想让我们更关注它们在后面几章.第二章，我们将看到listview的外貌改变和一些类3D图像算法。最后一章，我们将改变list的行为并且添加一些物理动力学进去，一些非常能提升外观和感觉的东西。&lt;/p&gt;

&lt;p&gt;虽然这里用到的技术和在X10 Mini上用到的一样，当这篇教材的目的不是仅仅拷贝一个看起来很特殊的list，而是教你实现自己的listview。我很确定你肯定有很多关于你的listview该看起来怎么样，它的行为和它用来干嘛的主意。&lt;/p&gt;

&lt;h3&gt;Hello AdapterView&lt;/h3&gt;

&lt;p&gt;当我们瞄准一个list（能显示其他view）,我们需要继承ViewGroup,更合适的是AdapterView。（原因，或者更多的原因我们不从AbsListView继承，是因为它不允许我们在list上做有活力的效果）。那么，让我们从开始建立安卓项目并且创建一个继承自AdapterView&lt;Adapter&gt; 的 MyListView 开始吧，AdapterView有四个抽象函数我们需要去实现:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;getAdapter()&lt;/li&gt;
&lt;li&gt;setAdapter()&lt;/li&gt;
&lt;li&gt;getSelectedView()&lt;/li&gt;
&lt;li&gt;setSelection()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;getAdapter()和setAdapter()直接实现，其他两个现在先仅仅抛出异常.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class MyListView extends AdapterView {
    /** The adapter with all the data */
    private Adapter mAdapter;
    public MyListView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    @Override
    public void setAdapter(Adapter adapter) {
        mAdapter = adapter;
        removeAllViewsInLayout();
        requestLayout();
    }
    @Override
    public Adapter getAdapter() {
        return mAdapter;
    }
    @Override
    public void setSelection(int position) {
        throw new UnsupportedOperationException(&amp;quot;Not supported&amp;quot;);
    }
    @Override
    public View getSelectedView() {
        throw new UnsupportedOperationException(&amp;quot;Not supported&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里唯一值得注意的是setAdapter方法。当我们获得一个新的Adapter我们移除之前所有的视图，然后请求一个布局，并且按照adapter放置视图。如果我们现在创建一个activity和带有假数据的adapter，然后使用新视图，我们将得不到任何东西，在屏幕上。这是因为如果我们要在屏幕上得到一些东西，我们需要重写onLayout()方法。&lt;/p&gt;

&lt;h4&gt;显示我们的第一个视图&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&quot;http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int&quot;&gt;onLayout( )&lt;/a&gt; )中，我们从adpater中获取视图，并且添加他们作为一个子视图。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    // if we don&amp;#39;t have an adapter, we don&amp;#39;t need to do anything
    if (mAdapter == null) {
        return;
    }
    if (getChildCount() == 0) {
        int position = 0;
        int bottomEdge = 0;
        while (bottomEdge &amp;amp;lt; getHeight() &amp;amp;amp;&amp;amp;amp; position &amp;amp;lt; mAdapter.getCount()) {
            View newBottomChild = mAdapter.getView(position, null, this);
            addAndMeasureChild(newBottomChild);
            bottomEdge += newBottomChild.getMeasuredHeight();
            position++;
        }
    }
    positionItems();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So，What happends hers? 首先执行父调用和空值检查，然后开始真正有用的代码。如果我们还没有添加任何子节点，那么我们就开始那么做。这个while循环直到我们添加足够多的视图覆盖整个屏幕为止。当我们从adapter获得一个视图，我们就把它添加为一个子节点，然后我们需要测量(measure)它，为的是得到它的正确尺寸。当我们添加完所有的视图，我们把它们放置到正确的位置.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;/**
 * Adds a view as a child view and takes care of measuring it
 *
 * @param child The view to add
 */
private void addAndMeasureChild(View child) {
    LayoutParams params = child.getLayoutParams();
    if (params == null) {
        params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    }
    addViewInLayout(child, -1, params, true);
    int itemWidth = getWidth();
    child.measure(MeasureSpec.EXACTLY | itemWidth, MeasureSpec.UNSPECIFIED);
}
/**
 * Positions the children at the &amp;amp;quot;correct&amp;amp;quot; positions
 */
private void positionItems() {
    int top = 0;
    for (int index = 0; index &amp;lt; getChildCount(); index++) {
        View child = getChildAt(index);
        int width = child.getMeasuredWidth();
        int height = child.getMeasuredHeight();
        int left = (getWidth() - width) / 2;
        child.layout(left, top, left + width, top + height);
        top += height;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些代码比较简单，自解释，所以我不准备过多描述。虽然我在测量子视图时走了点捷径，但是这些代码在大部分情况下是工作良好的。positioItems()从top（0)开始，然后布局这些子视图，一个挨着一个，没有任何padding。值得注意的是，我们忽略了list可能有的padding.&lt;/p&gt;

&lt;h3&gt;滑动&lt;/h3&gt;

&lt;p&gt;如果现在运行这些代码，我们在屏幕上得到一些东西了。然而，这一点交互的感觉也没有（interactive）。当我们触摸屏幕时它不会滑动，我们也不能点击任何item.要让触摸生效，我们需要重写 onTouchEvent()。&lt;/p&gt;

&lt;p&gt;仅仅使其滑动的触摸逻辑是十分简单的，当我们得到一个按下事件，我们保存下按下事件的位置，和list的位置。我们将使用第一个item的top作为list的位置(position)，当我们获得一个移动事件，我们计算与按下事件的距离，然后根据开始位置和当前位置的距离重新安置list。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
    if (getChildCount() == 0) {
        return false;
    }
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mTouchStartY = (int)event.getY();
            mListTopStart = getChildAt(0).getTop();
            break; 
        case MotionEvent.ACTION_MOVE:
            int scrolledDistance = (int)event.getY() - mTouchStartY;
            mListTop = mListTopStart + scrolledDistance;
            requestLayout();
            break;
        default:
            break;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
  </entry>
  
  <entry>
    <title>追踪运动 (译文)</title>
    <link href="///2013/05/10/movement.html"/>
    <updated>2013-05-10T00:00:00+08:00</updated>
    <id>///2013/05/10/movement</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://developer.android.com/training/gestures/movement.html&quot;&gt;源链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本课程将讨论如何在触摸事件中追踪运动&lt;/p&gt;

&lt;p&gt;一个新的onTouchEvent()是被一个ACTION_MOVE事件触发的，无论何时当前触摸包含位置，压力，或者大小改变。如在Detecting Common Gestures中讨论的，所有的事件被记录在onTouchEvent()中的MotionEvent参数中.&lt;/p&gt;

&lt;p&gt;因为基于手指的触摸不总是精致的交互形式，检测触摸事件经常基于运动而不是单个触点。为了帮助应用区分(distingush)基于运动的手势（如 swipe）和非移动手势（如单击) ,Android包含了“touch slop”概念。Touch slop指的是在这个手势被解释为一个运动手势前， 用户触摸的像素距离。更多的这个主题的讨论，见 Managing Touch Events in a ViewGroup。&lt;/p&gt;

&lt;p&gt;有不同方式去追踪手势运动，取决与你的应用需要，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个目标的开始与结束（如，移动一个在屏幕上的物体，从点A到点B)&lt;/li&gt;
&lt;li&gt;目标点正运行的方向，通过x和y坐标的方向决定&lt;/li&gt;
&lt;li&gt;History，你可以通过调用MotionEvent的getHistorySize()方法，找到一个手势的History信息。你可以通过MotionEvent的 getHistorical&amp;lt;Value&amp;gt;方法获得每个History事件的位置，大小，时间，压力。History信息对于渲染用户手指的路径(trail)十分有效，如为触摸绘画.参考更多细节MotionEvent。&lt;/li&gt;
&lt;li&gt;目标移过触摸屏幕的速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;跟踪速度&lt;/h3&gt;

&lt;p&gt;你可以获得一个简单的基于距离和(或)目标移动方向的运动手势，但是速度通常是在追踪手势特性甚至决定是否一个手势发生的决定性因素 。为了使计算速度更简单，Android提供了VelocityTracker类和VelocityTrackerCompat类在支持包中。VolocityTracker 帮助你追踪触摸事件的速度。对于某些将速度作为部分标准的手势，如扫，这是十分有用的。&lt;/p&gt;

&lt;p&gt;以下这个示例，说明了VelocityTrackerAPI中的方法目的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class MainActivity extends Activity {
    private static final String DEBUG_TAG = &amp;quot;Velocity&amp;quot;;
        ...
    private VelocityTracker mVelocityTracker = null;
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int index = event.getActionIndex();
        int action = event.getActionMasked();
        int pointerId = event.getPointerId(index);
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                if(mVelocityTracker == null) {
                    // Retrieve a new VelocityTracker object to watch the velocity of a motion.
                    mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    // Reset the velocity tracker back to its initial state.
                    mVelocityTracker.clear();
                }
                // Add a user&amp;#39;s movement to the tracker.
                mVelocityTracker.addMovement(event);
                break;
            case MotionEvent.ACTION_MOVE:
                mVelocityTracker.addMovement(event);
                // When you want to determine the velocity, call 
                // computeCurrentVelocity(). Then call getXVelocity() 
                // and getYVelocity() to retrieve the velocity for each pointer ID. 
                mVelocityTracker.computeCurrentVelocity(1000);
                // Log velocity of pixels per second
                // Best practice to use VelocityTrackerCompat where possible.
                Log.d(&amp;quot;&amp;quot;, &amp;quot;X velocity: &amp;quot; + 
                        VelocityTrackerCompat.getXVelocity(mVelocityTracker, 
                        pointerId));
                Log.d(&amp;quot;&amp;quot;, &amp;quot;Y velocity: &amp;quot; + 
                        VelocityTrackerCompat.getYVelocity(mVelocityTracker,
                        pointerId));
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                // Return a VelocityTracker object back to be re-used by others.
                mVelocityTracker.recycle();
                break;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你需要在ACTION&lt;em&gt;MOVE事件后计算速度，而不是ACTION&lt;/em&gt;UP.如果你ACTION_UP后计算，X和Y速度将是0&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>当ViewPager嵌套在ScrollView/ListView里时，手势冲突如何处理？</title>
    <link href="///2013/05/10/intercept-touchevent.html"/>
    <updated>2013-05-10T00:00:00+08:00</updated>
    <id>///2013/05/10/intercept-touchevent</id>
    <content type="html">&lt;p&gt;有时我们需要将ViewPager嵌套在其他已经含有手势动作的ViewGroup里,如ScrollView,ListView时，会造成手势冲突，如表现为ViewPager向左划时，不小心向上移动了一点距离，ViewPager立刻回弹到原始位置。&lt;/p&gt;

&lt;p&gt;主要问题出在ScrollView/ListView作为ViewPager的ParentView，会先接受到触摸信息，而且他们对上下滑动是会做出拦截动作，并接管触摸信息的向下传递，导致ViewPager滑动异常。
先看一种&lt;a href=&quot;http://justwyy.iteye.com/blog/1567390&quot;&gt;解决方式&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class ScrollViewExtend extends ScrollView {  
    private float xDistance, yDistance, xLast, yLast;  
    public ScrollViewExtend(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
    @Override  
    public boolean onInterceptTouchEvent(MotionEvent ev) {  
        switch (ev.getAction()) {  
            case MotionEvent.ACTION_DOWN:  
                xDistance = yDistance = 0f;  
                xLast = ev.getX();  
                yLast = ev.getY();  
                break;  
            case MotionEvent.ACTION_MOVE:  
                final float curX = ev.getX();  
                final float curY = ev.getY();             
                xDistance += Math.abs(curX - xLast);  
                yDistance += Math.abs(curY - yLast);  
                xLast = curX;  
                yLast = curY;  
                if(xDistance &amp;gt; yDistance){  
                    return false;  
                }    
        }  
        return super.onInterceptTouchEvent(ev);  
    }  
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式的确可以解决这个问题，但是其实Google已经提供了一个函数来解决ParentView与ChildView手势冲突的问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由ViewPager在OnTouch/onInterceptTouchEvent，dispatchTouchEvent中调用即可。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>ACTION_MASK 是用来干嘛的？</title>
    <link href="///2013/05/10/action_mask.html"/>
    <updated>2013-05-10T00:00:00+08:00</updated>
    <id>///2013/05/10/action_mask</id>
    <content type="html">&lt;p&gt;我们经常可以看到这样的代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;int action=event.getAction();
switch(action&amp;amp;MotionEvent.ACTION_MASK){
    // balabala
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从字面上理解，即为动作与上动作掩码.看下这些常量的值&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;ACTION_MASK             0x000000ff
ACTION_DOWN             0x00000000
ACTION_UP               0x00000001  
ACTION_MOVE             0x00000002 
ACTION_POINTER_DOWN     0x00000005 
ACTION_POINTER_UP       0x00000006 
ACTION_POINTER_1_DOWN   0x00000005            
ACTION_POINTER_1_UP     0x00000006   
ACTION_POINTER_2_DOWN   0x00000105   
ACTION_POINTER_2_UP     0x00000106 
ACTION_POINTER_3_DOWN   0x00000205           
ACTION_POINTER_3_UP     0x00000206 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现单指DOWN/UP分别为 0x005和0x006,
而双值和三指DOWN/UP分别为 0x105和0x106,0x205和0x206&lt;/p&gt;

&lt;p&gt;假设当前触摸动作为ACTION&lt;em&gt;POINTER&lt;/em&gt;2_DOWN时，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;int action=0x105;
int maskAction=0x0ff&amp;amp;0x105; //  maskAction=0x005;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此，触摸动作含义改变为ACTION&lt;em&gt;POINTER&lt;/em&gt;DOWN&lt;/p&gt;

&lt;p&gt;总结，Android在很多需要性能的地方都采用了这种传入int类型，再加掩码操作。如onMeasure。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>检测常见的手势 （译文）</title>
    <link href="///2013/05/10/Detecting-Common-Gestures.html"/>
    <updated>2013-05-10T00:00:00+08:00</updated>
    <id>///2013/05/10/Detecting-Common-Gestures</id>
    <content type="html">&lt;p&gt;一个触摸手势发生在一个用户将一个或多个手指放在触摸屏上，然后你的应用将这些触摸事件(pattern)翻译为一个具体的手势。有两个相应的阶段去作手势检测:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;收集关于触摸事件的数据.&lt;/li&gt;
&lt;li&gt;解释(interperting)这些数据，看它是否符合你的应用程序所支持的手势的标准(criteria).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;支持包/类&lt;/h3&gt;

&lt;p&gt;本课程中的示例使用了GestureDetectorCompat 和MotionEventCompat 类.这些类在支持包中.当可能需要在Android 1.6或者更高的系统中使用时，你应该使用支持包。注意，MotionEventCompat &lt;em&gt;不是&lt;/em&gt; MotionEvent类的替代版。相反，它提供了多种静态方法 ，为了接收已经结合事件的期望动作，传递你的MotionEvent对象。&lt;/p&gt;

&lt;h3&gt;收集数据&lt;/h3&gt;

&lt;p&gt;当用户将一个或多个手指放在屏幕上，在可接收触摸事件的视图上触发回调函数 onTouchEvent().对于每个触摸事件序列(位置，压力，大小，另一个手指的添加等),最终确定为一个手势，onTouchEvent()会多次调用(fired)&lt;/p&gt;

&lt;p&gt;当用户第一次接触屏幕时，手势开始，系统追踪用户手指的位置，手势也跟着继续，直到捕获用户的手指离开屏幕时结束。始终相互作用，传递(delivered)到onTouchEvent()的MotionEvent提供了每个交互的细节。你的应用可以使用这些提供了MotionEvent的数据去决定是否一个手势动作发生了值得去关注。&lt;/p&gt;

&lt;h3&gt;在Activity或者View中捕获触摸事件&lt;/h3&gt;

&lt;p&gt;重载onTouchEvent()回调函数，以拦截触摸事件在Activity或者View&lt;/p&gt;

&lt;p&gt;以下片段使用了getActionMasked()去提取用户从eventParameter执行的动作。它提供给你原始数据，由你决定是否一个手势是你关心发生的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class MainActivity extends Activity {
// This example shows an Activity, but you would use the same approach if
// you were subclassing a View.
@Override
public boolean onTouchEvent(MotionEvent event){ 
    int action = MotionEventCompat.getActionMasked(event);
    switch(action) {
        case (MotionEvent.ACTION_DOWN) :
            Log.d(DEBUG_TAG,&amp;quot;Action was DOWN&amp;quot;);
            return true;
        case (MotionEvent.ACTION_MOVE) :
            Log.d(DEBUG_TAG,&amp;quot;Action was MOVE&amp;quot;);
            return true;
        case (MotionEvent.ACTION_UP) :
            Log.d(DEBUG_TAG,&amp;quot;Action was UP&amp;quot;);
            return true;
        case (MotionEvent.ACTION_CANCEL) :
            Log.d(DEBUG_TAG,&amp;quot;Action was CANCEL&amp;quot;);
            return true;
        case (MotionEvent.ACTION_OUTSIDE) :
            Log.d(DEBUG_TAG,&amp;quot;Movement occurred outside bounds &amp;quot; +
                    &amp;quot;of current screen element&amp;quot;);
            return true;      
        default : 
            return super.onTouchEvent(event);
    }      
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后你可以做你自己的处理在这些事件上，去决定一个手势是否发生。当你需要做一个定制的手势时，这是必须要做的过程。然而，如果你的应用使用常用的手势如双击，长按，扫等等，你可以使用GestureDetector类的优势。GestureDetector将事情简化，它不需要你自己处理个别的触摸时间就可以检测常见的手势.见讨论&lt;a href=&quot;http://developer.android.com/training/gestures/detector.html#detect&quot;&gt;Detect Gestures&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;在单个View中捕获触摸事件&lt;/h3&gt;

&lt;p&gt;作为OnTouchEvent()的代替，你可以使用setOnTouchListener()方法将一个View.OnTouchListener依附(attach)到任何View对象上去。它使得我们无需子类化一个已经存在的View，而可以去监听触摸事件。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;View myView = findViewById(R.id.my_view); 
myView.setOnTouchListener(new OnTouchListener() {
    public boolean onTouch(View v, MotionEvent event) {
        // ... Respond to touch events       
        return true;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你创建了一个监听器，在处理ACTION&lt;em&gt;DOWN事件后返回 false ，你需要注意了。如果你这么做了，这个监听器将接收不到随后的ACTION&lt;/em&gt;MOVE和ACTION&lt;em&gt;UP 事件（String of events)。这是因为ACTION&lt;/em&gt;DOWN是所有触摸事件的触发点。&lt;/p&gt;

&lt;p&gt;如果你创建了一个定制View，你可以重载onTouchEvent()，如以上讨论的。&lt;/p&gt;

&lt;h3&gt;检测手势&lt;/h3&gt;

&lt;p&gt;Android提供了GestureDetector类来检测通用手势，它支持了一些手势在onDown(),onLongPress(),onFling()等方法中。你可以结合OnTouchEvent()使用GestureDetector，如刚才讨论的。&lt;/p&gt;

&lt;h3&gt;检测所有支持的手势&lt;/h3&gt;

&lt;p&gt;当你实例化一个GestureDetectorCompat对象时，其中一个参数需要实现GestureDetector.OnGestureListener接口。GestureDetector.OnGestureListener通知用户何时一个特定的触摸事件发生。为了使你的GestureDetector对象可以接收事件，你需要重载View或者Activity的OnTouchEvent()方法，然后沿着所有被观察的事件传递到检测实例。&lt;/p&gt;

&lt;p&gt;接下来的片段中，一个返回true的特定on&amp;lt;TouchEvent&amp;gt;意味着你已经处理了触摸时间。返回false则通过视图栈向下传递事件，直到触摸被成功处理。&lt;/p&gt;

&lt;p&gt;执行下面的代码，感受下当你与屏幕互动(interact)时，动作是如何被触发的，以及每个触摸事件中MotionEvent的内容。你将会了解即使是单个交互动作有多少数据生产。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class MainActivity extends Activity implements 
        GestureDetector.OnGestureListener,
        GestureDetector.OnDoubleTapListener{
    private static final String DEBUG_TAG = &amp;quot;Gestures&amp;quot;;
    private GestureDetectorCompat mDetector; 
    // Called when the activity is first created. 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // Instantiate the gesture detector with the
        // application context and an implementation of
        // GestureDetector.OnGestureListener
        mDetector = new GestureDetectorCompat(this,this);
        // Set the gesture detector as the double tap
        // listener.
        mDetector.setOnDoubleTapListener(this);
    }
    @Override 
    public boolean onTouchEvent(MotionEvent event){ 
        this.mDetector.onTouchEvent(event);
        // Be sure to call the superclass implementation
        return super.onTouchEvent(event);
    }
    @Override
    public boolean onDown(MotionEvent event) { 
        Log.d(DEBUG_TAG,&amp;quot;onDown: &amp;quot; + event.toString()); 
        return true;
    }
    @Override
    public boolean onFling(MotionEvent event1, MotionEvent event2, 
            float velocityX, float velocityY) {
        Log.d(DEBUG_TAG, &amp;quot;onFling: &amp;quot; + event1.toString()+event2.toString());
        return true;
    }
    @Override
    public void onLongPress(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onLongPress: &amp;quot; + event.toString()); 
    }
    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
            float distanceY) {
        Log.d(DEBUG_TAG, &amp;quot;onScroll: &amp;quot; + e1.toString()+e2.toString());
        return true;
    }
    @Override
    public void onShowPress(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onShowPress: &amp;quot; + event.toString());
    }
    @Override
    public boolean onSingleTapUp(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onSingleTapUp: &amp;quot; + event.toString());
        return true;
    }
    @Override
    public boolean onDoubleTap(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onDoubleTap: &amp;quot; + event.toString());
        return true;
    }
    @Override
    public boolean onDoubleTapEvent(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onDoubleTapEvent: &amp;quot; + event.toString());
        return true;
    }
    @Override
    public boolean onSingleTapConfirmed(MotionEvent event) {
        Log.d(DEBUG_TAG, &amp;quot;onSingleTapConfirmed: &amp;quot; + event.toString());
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;检测一个被支持手势的子集&lt;/h3&gt;

&lt;p&gt;如果你只是想要处理小部分的手势，你可以继承GestureDetector.SimpleOnGestureListener ，而不是GestureDetector.OnGestureListener接口。&lt;/p&gt;

&lt;p&gt;GestureDetector.SimpleOnGestureListener 提供所有On&amp;lt;TouchEvent&amp;gt;方法返回false的实现.因此你可以只重载你所关心的方法。例如，接下来的片段创建了一个继承GestureDetector.SimpleOnGestureListener类，重载了OnFling()和OnDown();&lt;/p&gt;

&lt;p&gt;无论你是否使用GestureDetector.OnGestureListener，这是一个最佳实践(best practice)去实现一个返回true的 onDown()方法。因为所有的手势开始与一个onDown()信息。如果你在onDown()返回false，GestureDetector.SimpleOnGestureListener只做默认动作，系统假定你要忽视手势的剩余部分(rest)，然后GestureDetector.OnGestureListener的其他方法将永远不会被调用。这可能是在你应用中的一个潜在异常(potential)。除非你真的是要忽略手势，你才应该返回false.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot;&gt;public class MainActivity extends Activity { 
    private GestureDetectorCompat mDetector; 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mDetector = new GestureDetectorCompat(this, new MyGestureListener());
    }
    @Override 
    public boolean onTouchEvent(MotionEvent event){ 
        this.mDetector.onTouchEvent(event);
        return super.onTouchEvent(event);
    }
    class MyGestureListener extends GestureDetector.SimpleOnGestureListener {
        private static final String DEBUG_TAG = &amp;quot;Gestures&amp;quot;; 
        @Override
        public boolean onDown(MotionEvent event) { 
            Log.d(DEBUG_TAG,&amp;quot;onDown: &amp;quot; + event.toString()); 
            return true;
        }
        @Override
        public boolean onFling(MotionEvent event1, MotionEvent event2, 
                float velocityX, float velocityY) {
            Log.d(DEBUG_TAG, &amp;quot;onFling: &amp;quot; + event1.toString()+event2.toString());
            return true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
  </entry>
  

</feed>
